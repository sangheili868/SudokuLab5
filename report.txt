Chris Maheu
Lab 5 Report
Sudoku Game

File Location:
https://github.com/sangheili868/sudokulab5

	When running this program, the user is first asked to import a sudoku game. Any text file of a nine-by-nine grid of characters separated by spaces will work. After loading the file, it is displayed in a grid and the user is asked to input three things. The first two inputs must be integers 1-9, or an error will be displayed. After receiving correct input, the program places the third input in the cell with coordinates matching the first two inputs. For example, an input of 593 would place 3 in the ninth element of the fifth row. However, any attempt to place a number in an invalid spot based on the rules of sudoku results in an error message, and input is asked for again. This process repeats until the user inputs a q to quit or all cells are filled.

	This program uses the Puzzle class to store and manipulate the grid of numbers. This class has public functions display, setCell, and checkWin. It stores the numbers in a two-dimensional vector of a template type, so it works for any type of input. The class's constructor requires a file as input, which it stores into the vector. The display function uses a series of for loops to display the grid neatly. It calls the printRow function a total of nine times. The printRow function uses for loops to display all the elements in a single row of the vector. The checkWin function loops through all elements of the vector, and returns zero if any elements are zero. Otherwise, it returns 1. There is no way for the grid to be full and the player to have not won unless the starting file was bad. This is because the setCell function prevents any cheating. 
	The setCell function takes in coordinates and a value to place at those coordinates. First, it checks if the spot is already filled. If so, it outputs 1 and ends. If not, it proceeds to check all cells in the minigrid to see if any match the value trying to be placed. It calculates the position of top left corner cell of the minigrid that the cell to be modified is located in. This is accomplished with the formula (x/3)*3, where x is the x or y coordinate. For example, say a number is being placed in the position (7,4). The x coordinate, 7, is divided by three and truncated to get 2.333. This is truncated to get 2, which is multiplied by three to get an x-coordinate of 6. Similarly, a y-coordinate is calculated to be 3. So the top left corner of the minigrid that (7,4) is in is (6,3). This allows the function to easily check each other value in the minigrid. If any match the value trying to be placed, the function returns 2 and ends. If none match, the row is checked. This is accomplished with a for loop, where the y-coordinate is incremented across the grid, checking for value matches. 3 is returned if any match is found. The same is done for the column the number is being placed in, with a return value of 4. If none of these checks return, then the value at the position is changed, and the function returns zero.
	The main program receives the input file, and displays it as both an int array and char array, showing that the Puzzle class can take any data type as input. Next, checks if the grid is already complete, and if it does, ends immediately. If not, it enters a while loop that constitutes the player's turn sequences. The first step of each turn is to enter two do while loops. The outer one loops until the input provided places a valid cell. The inner loop continues until valid input is given by the user. Invalid input would mean the first two characters of the input are something other than a number from 1 to 9. The program places a cell by passing each character of the input to the setCell function, changing the first two characters to integers. The output of this function is passed to the displayerror function, which displays an error to the user if the value could not be placed, explaining where another number was found. This function also returns its input, and this output is used to check whether the loop should coutinue.If so, then a number was correctly placed, and the game checks to see if the grid is now full. If so, the game ends. If not, the loop continues and the user is asked for input again.

	This program was verified by inputting several bad values, and seeing the correct error messages. All checks for number placement were able to correctly identify value matches, and no input causes errors.

	I think the various ways the program checked for correct values are very efficient and straightforward, but there may be a way to have the minigrid check avoid checking the cells in the minigrid and the same row or column as the cell to be modified. Checking those is unnecessary because they are checked in the row and column checks. I feel that templating the Puzzle class was unnecessary. Because of the way it reads input, any input can be read and correctly processed as char. It would have been much easier to work with assuming the input is char instead of having to worry whether to convert ints to char or vice-versa. It would have been much simpler to convert to char in the driver program. Using only three characters as input makes it much easier for the user to enter coordinates quickly, but it would not work if the program were expanded for larger grids with greater than nine elements in a row or column. 
