Chris Maheu
Lab 6
Sudoku Solver

	This program begins by asking the user to input a sudoku text file. The puzzle is displayed on the screen. Then, the program solves the puzzle, listing some of its steps. Whenever it places a number in a cell, it states the location of the cell and the number placed, and the reasoning behind the placement. This can be because that value was the only possible value for that cell, or because that cell was the only possible spot for that value in its row, column, or minigrid. Also, every time the program has passed through the entire grid, it states how many times it has passed through the grid. Once it is done, it displays the completed puzzle. 

	This program builds off of the sudoku class developed in lab 5. It uses a three-dimensional vector poss to keep track of values that can possibly be placed in any cell. The solve() function begins initializing the poss vector. Then it enters a while loop that ends when the checkWin() function outputs a one. In each iteration of this while loop, the function first loops through all cells of the grid. If a cell has a zero, the function loops through all values (1-9) that can be placed in that cell. For each value, it checks if that value could be placed in that cell using the checkCell() function developed in the previous lab. After looping through all the values, it calls the checkPoss() function. This function performs various actions depending on the number of possibilities for the given cell. First, it counts these possibilities, and stores the value of the last possibility found for later use. If the cell has no possible values, the function prints that it cannot place any number at the position and the program ends because it has failed. If the cell has exactly one possible value, the function attempts to place that value in that cell using setCell(). The return of setCell is passed to checkOutput(), which displays text if the value could not be placed and explains why. If there is no error, the program states that it placed a value because that value was the only possible value for that cell, changes a static variable so the solve() function can tell that a value was changed. Then it sets all possible values to 0 in the poss vector. If the cell has exactly two possible values, the singleton algorithm is used. If the cell has more than two possible values, nothing is done this iteration.
	The singleton algorithm checks for pairs of cells that each can have one of two matching values, and are in the same column, row, or minigrid. If a pair like this is found, then all cells in the respective column, row, or minigrid except those two cells have the matching values set as not possible. This is accomplished by approaching each of the three cases seperately. The function takes a cell's coordinates as inputs, then tries to find matching cells. First, the possible values of the original cell are put into a vector for easy access. Next, the function loops through all cells in the same row as the original cell and checks if any has the same possibilities array as the original cell. If one is found, the function again loops through tall cells in that row, but skips over the pair of matching cells. For each cell it checks, it loops through the vector storing the possible values of the original cell and sets the current cell's possibility of having those values to not possible. This process is repeated in the same way for the original cell's column and minigrid, looping through all cells in the respective group.
	After the solve() function has looped through all cells in the grid, it checks each row to see if there is some value that can only be in one cell in that row. The checkRow() function loops through each row, and then each possible value, and then each element in the row. If any value is found to already exist in that row, then it moves to the next value. If exactly one cell is found to have that value as a possibility, then it sets that cell to that value using the same checks as described in the checkPoss() function as described above. The checkCol() and checkMini() functions check for lone possibilities in all columns and minigrids, respectively. Finally, the solve() function states how many iterations it has gone through so far, and then checks if this iteration made any changes to the grid. If it did not, then the program ends because it needs more algorithms to solve harder puzzles. If it did change, thnen the function continues to the next iteration, unless the puzzle is complete. When that happens, the program ends. 

	This program was verified using the easy (puz1.txt in the dropox) and medium puzzles provided on Piazza, as well as several harder puzzles found online. The solver found on the website http://www.sudokuwiki.org/sudoku.htm was used to check that the program was producing correctly completed puzzles and to check what the next correct step would be when the program failed. In its current version, the program can solve all puzzles in the dropbox except satan.txt, which requires recognition of a naked triple as described at that website. 

	This program uses the following algorithms to find values to put in cells: single possibility for cell, singleton(or naked pairs), and single cell for value in unit. The first part developed was the single possibility for cell, which solved the easy puzzle but failed to solve the hard puzzle. Next, I attempted the singleton algorithm, but misunderstood how it worked and made it far too specific too be useful. I instead implemented the single cell for value in unit algorithm. Now the program could solve the medium puzzle, but it failed to solve the hard puzzle found online. Discovering why it failed for this puzzle helped me to understand the singleton algorithm fully, so I was then able to implement it effectively. This allowed the program to now solve both the hard and evil puzzles. 
